<html>
<head>
    <title>Tweetmap Java 8 Workshop - Activator Template</title>
</head>
<body>
<div>
    <p>Welcome to the Tweetmap  Java 8  Workshop! You've just created a simple Play Framework application! We will use this as
        the starting template for the Tweetmap  Java 8  Workshop.</p>

    <p>Within the Activator UI you can:

    <ul>

    <li>Browse & edit the code (select Code.  To save a file the keyboard shortcut command-s works.)</li>
    <li>Add & delete files from the code (select Code and then the plus sign.  To delete open the file and click on delete)</li>
    <li>Open the code in IntelliJ IDEA or Eclipse (select Code, then the gear dropdown)</li>
    <li>See the compile output (select Compile)</li>
    <li>Test the application (select Test)</li>
    <li>Run the application (select Run)</li>
    </ul>

    </p>


    <h2>View the App</h2>

    <p>
        Once the application has been compiled and the server started, your application can be accessed at: <a
            href="http://localhost:9000" target="_blank">http://localhost:9000</a><br/>
    </p>
     <p>   Check in <a href="#run" class="shortcut">Run</a> to see the server status.<br/>
    </p>
</div>
<div>
    <h2>Reactive Requests</h2>

    <p>
        <ul>
            <li>Routes</li>
            <li>Controllers</li>
            <li>Views</li>
            <li>JSON</li>
        </ul>
    </p>

    <p>1. Create a new route in<a href="#code/conf/routes" class="shortcut">conf/routes</a> with the following route:</p>

    <p>GET   &nbsp;&nbsp; /tweets  &nbsp;&nbsp;&nbsp;&nbsp; controllers.Tweets.search(query: String)</p>

<p>2. Update <a href="#code/app/controllers/Tweets.java" class="shortcut">app/controllers/Tweets.java</a> to add a reactive request handler for /tweets:</p>
<p></p>
 <pre><code>
public class Tweets extends Controller {

    public static Result index() {
        return ok(views.html.index.render("TweetMap"));
    }

    public static Promise&lt;Result&gt; search(String query) {
        return fetchTweets(query)
            .map(jsonNode -> ok(jsonNode));
    }

     /**
     * Fetch the latest tweets and return the Promise of the json results.
     * This fetches the tweets asynchronously and fulfills the promise when the results are returned.
     *
     * @param query
     * @return
     */
     public static Promise&lt;JsonNode&gt; fetchTweets(String query) {
        Promise&lt;WSResponse&gt; responsePromise = WS.url("http://twitter-search-proxy.herokuapp.com/search/tweets").setQueryParameter("q", query).get();
        //can also map using method references - WSResponse::asJson
        return responsePromise
            .filter(response -> response.getStatus() == Http.Status.OK)
            .map(response -> response.asJson())
            .recover(Tweets::errorResponse);
     }

     /**
     * The error response when the twitter search fails.
     *
     * @param ignored
     * @return
     */
     public static JsonNode errorResponse(Throwable ignored) {
         return Json.newObject().put("error", "Could not fetch the tweets");
     }

 }
</code></pre>

    <p>3. Test it: <a href="http://localhost:9000/tweets?query=typesafe" target="_blank">http://localhost:9000/tweets?query=typesafe</a></p>
    <p></p>
</div>

<div>
    <h2>AngularJS UI</h2>
    <ul>
        <li>Reactive UI</li>
        <li>JavaScript</li>
    </ul>

<p>1. The <a href="#code/build.sbt" class="shortcut">build.sbt</a> file already has dependencies on AngularJS and Bootstrap:</p>

    <code>
        <pre>
"org.webjars" % "bootstrap" % "3.0.0",
"org.webjars" % "angularjs" % "1.2.16",
        </pre>
    </code>

<p>2.  AngularJS has already been enabled in the <a href="#code/app/views/main.scala.html" class="shortcut">main twirl template</a></p>

<pre><code>
&lt;html ng-app="tweetMapApp"&gt;
&lt;script src="@routes.Assets.versioned("lib/angularjs/angular.min.js")"&gt;&lt;/script&gt;
</code></pre>


<p>3. Add the following to the index.js file in <a href="#code/app/assets/javascripts" class="shortcut">/app/assets/javascripts</a> to fetch the tweets:</p>

<pre><code>

app.factory('Twitter', function($http, $timeout) {

    var twitterService = {
        tweets: [],
        query: function (query) {
            $http({method: 'GET', url: '/tweets', params: {query: query}}).
                success(function (data) {
                    twitterService.tweets = data.statuses;
                });
        }
    };

    return twitterService;
});

app.controller('Search', function($scope, $http, $timeout, Twitter) {

    $scope.search = function() {
        Twitter.query($scope.query);
    };

});

app.controller('Tweets', function($scope, $http, $timeout, Twitter) {

    $scope.tweets = [];

    $scope.$watch(
        function() {
            return Twitter.tweets;
        },
        function(tweets) {
            $scope.tweets = tweets;
        }
    );

});
</code></pre>

    <p>4. Update <a href="#code/app/views/index.scala.html" class="shortcut">index.scala.html</a> file:

<pre><code>
@(message: String)

@main(message) {

    &lt;div ng-controller="Tweets"&gt;
        &lt;ul&gt;
            &lt;li ng-repeat="tweet in tweets"&gt;{{tweet.text}}&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
}
</code></pre>
    <p>5. Run the app, make a query, and verify the tweets show up: <a href="http://localhost:9000/" target="_blank">http://localhost:9000</a></p>
</div>

<div>
    <h2>Add Websockets</h2>

    <p>1. Add a route for the websocket connection to the <a href="#code/conf/routes" class="shortcut">routes </a>file:</p>

    <p>GET &nbsp;&nbsp /ws     &nbsp;&nbsp;&nbsp;&nbsp;              controllers.Tweets.ws</p>

    <p>2. Add a new controller method to create the Websocket in <a href="#code/app/controllers/Tweets.java" class="shortcut">app/controllers/Tweets.java:</a></p>

<pre><code>
public static WebSocket&lt;JsonNode&gt; ws() {
    return WebSocket.whenReady((in, out) -> {

        in.onMessage(jsonNode -> {
            String query = jsonNode.findPath("query").textValue();
            fetchTweets(query).onRedeem(json -> out.write(json));
        });

        in.onClose(() -> {
        });
     });
}
</code></pre>

    <p>4. Update the app.factory section of <a href="#code/app/assets/javascripts/index.js" class="shortcut">index.js </a>with:

<pre><code>
    var ws = new WebSocket("ws://localhost:9000/ws");

    var twitterService = {
        tweets: [],
        query: function (query) {
            ws.send(JSON.stringify({query: query}));
        }
    };

    ws.onmessage = function(event) {
        $timeout(function() {
            twitterService.tweets = JSON.parse(event.data).statuses;
        });
    };

    return twitterService;
</code></pre>

    <p>5. Run the app and verify the tweets show up: <a href="http://localhost:9000/" target="_blank">http://localhost:9000</a></p>


</div>

<div>
    <h2>Create an Akka Actor</h2>

    <p>1. Create a new UserActor.java file in <a href="#code/app/actors" class="shortcut">/app/actors</a> containing:</p>

<pre><code>

package actors;

import akka.actor.*;
import akka.japi.pf.ReceiveBuilder;
import com.fasterxml.jackson.databind.JsonNode;
import controllers.Tweets;
import scala.concurrent.duration.Duration;

import java.util.Optional;
import java.util.concurrent.TimeUnit;

public class UserActor extends AbstractActor {

    /**
    * The query to search for - empty if a query has not been sent from the user
    */
    public Optional&lt;String&gt; optQuery = Optional.empty();

    /**
    * Creates a new UserActor using these Props.
    *
    * @param out
    * @return
    */
    public static Props props(ActorRef out) {
        return Props.create(UserActor.class, out);
    }

    /**
    * The out ActorRef is used to write back out to the websocket client
    * It is created by Play and set when the UserActor is created.
    */
    private final ActorRef out;

    /**
    * Construct the UserActor and initialize the receive block.
    * The receive block defines this actor handles.
    *
    * @param out
    */
    public UserActor(ActorRef out) {
        this.out = out;

        receive(ReceiveBuilder.
            match(JsonNode.class, jsonNode -> {
                String query = jsonNode.findPath("query").textValue();
                optQuery = Optional.of(query);
                runFetchTweets(query);
            }).
            match(Update.class, update -> optQuery.ifPresent(this::runFetchTweets)).
            matchAny(o -> System.out.println("received unknown message")).build()
        );
    }

    /**
    * Fetch the latest tweets for a given query and send the results to
    * the out actor - which in turns sends it back up to the client via a websocket.
    *
    * @param query
    */
    private void runFetchTweets(String query) {
        Tweets.fetchTweets(query).onRedeem(json -> {
            out.tell(json, self());
        });
    }


    /**
    * The Update class is used to send a message to this actor to
    * re-run the query and send the results to the client.
    */
    public static final class Update {
    }

    private final ActorSystem system = getContext().system();

    //This will schedule to send the Update message
    //to this actor after 0ms repeating every 5s.  This will cause this actor to search for new tweets every 5 seconds.
    Cancellable cancellable = system.scheduler().schedule(Duration.Zero(),
            Duration.create(5, TimeUnit.SECONDS), self(), new Update(),
            system.dispatcher(), null);

}
</code></pre>

</div>

<div>
    <h2>Update the Websocket</h2>

    <p>1. Update the Websocket code to return an Actor in <a href="#code/app/controllers/Tweets.java" class="shortcut">app/controllers/Tweets.java</a></p>

<pre><code>

public static WebSocket&lt;JsonNode&gt; ws() {
    return WebSocket.whenReady((in, out) -> {

        ActorRef userActor = Akka.system().actorOf(UserActor.props(json -> out.write(json)));

        in.onMessage(jsonNode -> {
            userActor.tell(jsonNode, ActorRef.noSender());
        });

        in.onClose(() -> {
            Akka.system().stop(userActor);
        });
    });
}


/** Could also use the new Play 2.3 withActor function
    public static WebSocket&lt;JsonNode&gt; ws() {
        return WebSocket.withActor(UserActor::props);
    }
**/


</code></pre>

<p>5. Verify the tweets are being refreshed: <a href="http://localhost:9000/" target="_blank">http://localhost:9000</a></p>


</div>

<div>
    <h2>Update the Twitter Search to add Geo-Coding</h2>

    <p>1. Update <a href="#code/app/controllers/Tweets.java" class="shortcut">app/controllers/Tweets.java</a> to add geo-coding:</p>


<pre><code>
    /**
    * Fetch the latest tweets and return the Promise of the json results.
    * This fetches the tweets asynchronously and fulfills the promise when the results are returned.
    *
    * @param query
    * @return
    */
    public static Promise&lt;JsonNode&gt; fetchTweets(String query) {
        Promise&lt;WSResponse&gt; responsePromise = WS.url("http://twitter-search-proxy.herokuapp.com/search/tweets").setQueryParameter("q", query).get();
        //can also map using method references - WSResponse::asJson
        return responsePromise
        .filter(response -> response.getStatus() == Http.Status.OK)
        .map(response -> {
            JsonNode jsonNode = response.asJson();
            transformStatusResponses(jsonNode);
            return jsonNode;
        });
    }


    /**
    * Transform the json responses by adding geo coordinates to each tweet.
    *
    * @param jsonNode
    */
    private static void transformStatusResponses(JsonNode jsonNode) {
        jsonNode.findPath("statuses")
            .forEach(nextStatus -> setCoordinates((ObjectNode) nextStatus));
    }

    /**
    * Most tweets don't actually have their geo-location set so just randomly set the latitude and longitude.
    *
    * @param nextStatus
    */
    private static void setCoordinates(ObjectNode nextStatus) {
        ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode();
        arrayNode.add(randomLat()).add(randomLon());
        nextStatus.set("coordinates", arrayNode);
    }

    private static Random rand = new java.util.Random();

    private static double randomLat() {
        return (rand.nextDouble() * 180) - 90;
    }

    private static double randomLon() {
        return (rand.nextDouble() * 360) - 180;
    }


</code></pre>

</div>

<div>
    <h2>Add the Tweet Map</h2>

    <ul>
        <li>WebJars</li>
    </ul>

    <p>1. The webjar dependency on leaflets has already been added to <a href="#code/build.sbt" class="shortcut">build.sbt</a></p>

    <p>2. The Leaflet CSS and JS have already been added to <a href="#code/app/views/main.scala.html" class="shortcut">main.scala.html </a>file:</p>

<pre><code>
    &lt;link rel='stylesheet' href='@routes.Assets.versioned("lib/leaflet/leaflet.css")'&gt;
    &lt;script type='text/javascript' src='@routes.Assets.versioned("lib/leaflet/leaflet.js")'&gt;&lt;/script&gt;
    &lt;script type='text/javascript' src='@routes.Assets.versioned("lib/angular-leaflet-directive/angular-leaflet-directive.min.js")'&gt;&lt;/script&gt;
</code></pre>

    <p>3. Above the &lt;ul&gt; in <a href="#code/app/views/index.scala.html" class="shortcut">index.scala.html </a> add a map:</p>
    <pre><code>&lt;leaflet width="100%" height="500px" markers="markers"&gt;&lt;/leaflet&gt;</code></pre>


    <p>4. Update the first line of <a href="#code/app/assets/javascripts/index.js" class="shortcut">index.js </a> with:</p>

<pre><code>
    var app = angular.module('tweetMapApp', ["leaflet-directive"]);
</code></pre>

    <p>5. Update the app.controller('Tweets' ... section of the <a href="#code/app/assets/javascripts/index.js" class="shortcut">index.js </a> file with the following:</p>

<pre><code>
    $scope.tweets = [];
    $scope.markers = [];

    $scope.$watch(
        function() {
            return Twitter.tweets;
        },
        function(tweets) {
            $scope.tweets = tweets;

            $scope.markers = tweets.map(function(tweet) {
                return {
                    lng: tweet.coordinates[0],
                    lat: tweet.coordinates[1],
                    message: tweet.text,
                    focus: true
                }
            });
        }
    );

</code></pre>




<p>8. Go to <a href="http://localhost:9000" target="_blank">http://localhost:9000</a> to see the TweetMap!</p>
</div>

</body>
</html>
